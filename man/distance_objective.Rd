% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/objective-functions.R
\name{distance_objective}
\alias{distance_objective}
\title{Objective value for the cluster editing distance objective}
\usage{
distance_objective(features = NULL, distances = NULL, clusters,
  standardize = FALSE)
}
\arguments{
\item{features}{A vector, matrix or data.frame of data points. Rows
correspond to elements and columns correspond to features. A
vector represents a single feature.}

\item{distances}{Alternative data argument that can be used if
\code{features} is not passed. A N x N matrix representing the
pairwise dissimilarities between N elements. Larger values
indicate higher dissimilarity. Can be an object of class
\code{dist} (e.g., returned by \code{\link{dist}} or
\code{\link{as.dist}}) or a \code{matrix} where the entries of
the upper and lower triangular matrix represent the pairwise
dissimilarities.}

\item{clusters}{A vector representing (anti)clusters (e.g.,
returned by \code{\link{anticlustering}} or
\code{\link{balanced_clustering}}).}

\item{standardize}{Boolean - should the features be standardized
before anticlusters are created? Defaults to \code{FALSE}.
Standardization is done using the function \code{\link{scale}}
using the default settings (mean = 0, SD = 1). This argument
only works in combination with the \code{features} argument,
not with \code{distances}.}
}
\value{
The cluster editing objective
}
\description{
Check the objective value for a given clustering.
}
\details{
The cluster editing objective objective is given by the sum of the
pairwise distances between elements within the same (anti)clusters.
When the argument \code{features} is passed, the Euclidean distance
is used.
}
\note{
When using this function to check the results of
\code{\link{anticlustering}} or \code{\link{balanced_clustering}},
make sure that the \code{standardization} argument has the same value
when creating (anti)clusters and when calling \code{variance_objective}
(at least if \code{features} is used as input).
}
\examples{

data(iris)
distances <- dist(iris[1:60, -5])
## Clustering
clusters <- balanced_clustering(distances = distances, K = 3)
# This is low:
distance_objective(distances = distances, clusters = clusters)
## Anticlustering
anticlusters <- anticlustering(distances = distances, K = 3)
# This is higher:
distance_objective(distances = distances, clusters = anticlusters)


# Illustrates the cluster editing objective as the sum of distances
# within groups (needs an integer linear programming solver!)
n_elements <- 12
features <- matrix(runif(n_elements * 2), ncol = 2)
n_groups <- 2
clusters <- balanced_clustering(features, K = n_groups, method = "ilp")
anticlusters <- anticlustering(features, K = n_groups, method = "ilp")
par(mfrow = c(1, 2))
plot_clusters(features, clusters, within_connection = TRUE,
              main = "Minimum within-group distances")
plot_clusters(features, anticlusters, within_connection = TRUE,
              main = "Maximum within-group distances")

}
\references{
Böcker, S., Briesemeister, S., & Klau, G. W. (2011). Exact algorithms
for cluster editing: Evaluation and experiments. Algorithmica, 60,
316-334.

Grötschel, M., & Wakabayashi, Y. (1989). A cutting plane algorithm
for a clustering problem. Mathematical Programming, 45, 59–96.
}
