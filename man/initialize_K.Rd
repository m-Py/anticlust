% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/initialize_K.R
\name{initialize_K}
\alias{initialize_K}
\title{Generate an initial cluster assignment for anticlustering}
\usage{
initialize_K(N = NULL, K = NULL, n, groups = NULL)
}
\arguments{
\item{N}{The total number of items}

\item{K}{The number of subsets to be generated}

\item{n}{Either: a number indicating how many elements are selected
per subset. Or: A vector of length K. In the latter case, entries
represents the n per subset.}

\item{groups}{A vector of length N, alternative argument to N and K.
Represents the group for an element.}
}
\value{
The initialized cluster for each element
}
\description{
This function returns a vector that can be used as the \code{K} argument
in the function \code{\link{anticlustering}}. Some entries in this
vector may be NA to enable subset selection procedures (i.e., not each
item is assigned to a set).
}
\details{
If the sum of `n` per group is lower than `N`, the returned vector
will include NAs. If this vector is used as the \code{K} argument
for the \code{\link{anticlustering}}, \code{anticlustering} will
also output a vector that contains NAs (that is a permutation of the
input vector \code{K}). This way, it is possible to select only a
subset of the input items. It is also possible to create sets of
different sizes.
}
\examples{

# Example of how to use the function `anticlustering` to create two
# subset of stimuli from the schaper2019 data set. Two sets of n = 20
# each are created, one with kitchen items only and one with bathroom
# items only. The sets are parallelized on the means and standard
# deviations of four features.

head(schaper2019)
features <- schaper2019[, 3:6]

K <- initialize_K(groups = schaper2019$room, n = c(20, 20))
groups <- anticlustering(
  features,
  K = K,
  categories = schaper2019$room,
  objective = mean_sd_obj # this objective function makes most sense for subset selection
)
# Note that this subset selection based on two groups is
# no longer an anticlustering method (that would divide one pool of
# items into subsets)

table(K, schaper2019$room)
# Compare feature means by room
by(features, groups, function(x) round(colMeans(x), 2))
# Compare standard deviations by room
by(features, groups, function(x) round(apply(x, 2, sd), 2))


# Create sets of different size, optimizing anticluster editing objective:
K <- initialize_K(n = c(48, 24, 24))
anticlusters <- anticlustering(
  features,
  K = K,
  objective = "distance"
)

# Compare feature means by room
table(anticlusters)
by(features, anticlusters, function(x) round(colMeans(x), 2))
# Compare standard deviations by room
by(features, anticlusters, function(x) round(apply(x, 2, sd), 2))


}
