
#' Heuristic anticlustering using random sampling
#'
#' @param data The data that is optimized on (N x M feature matrix
#'     or N x N distance matrix)
#' @param K How many anticlusters should be created.
#' @param preclusters An optional vector representing the preclustering
#'     of the elements in \code{data}
#' @param obj_function An objective function where the first argument
#'     is a cluster assignment and the second argument is the data set.
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param categories A vector that represents categorical constraints.
#' @param parallelize Boolean. Indicates whether multiple processors should
#'     be used.
#' @param seed A value to fixate the random seed when using the random
#'     sampling method. When \code{parallelize} is \code{TRUE}, using
#'     this argument is the only way to ensure reproducibility.
#' @param ncores The number of cores to be used when parallelize is TRUE.
#'     This argument is not
#'     accessible from the exported function \code{anticlustering} and
#'     only exists because R CMD check does not allows to use more than
#'     two cores.
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling <- function(data, K, preclusters, obj_function,
                            nrep, categories,
                            parallelize, seed, ncores = NULL) {

  ## Determine objective function to be used
  sampling_plan <- get_sampling_plan(preclusters, categories)
  ## Sort data by constraint-inducing variable
  dat <- sort_by_group(data, preclusters, categories)

  if (parallelize) {
    best_assignment <- parallel_sampling(
      dat,
      K,
      nrep,
      sampling_plan,
      obj_function,
      seed,
      ncores
    )
  } else {
    if (argument_exists(seed)) {
      set.seed(seed)
    }
    best_assignment <- random_sampling_(
      dat,
      K,
      nrep,
      sampling_plan,
      obj_function
    )
  }

  ## Return anticluster assignment in original order
  dat[, 1] <- best_assignment
  dat <- sort_by_col(dat, 2)
  anticlusters <- dat[, 1]
  names(anticlusters) <- NULL
  anticlusters
}

# Extracted from the above function for readability
get_sampling_plan <- function(preclusters, categories) {
  ## Determine plan for random sampling
  sampling_plan <- "unrestricted"
  if (argument_exists(preclusters)) {
    sampling_plan <- "preclustering"
  } else if (argument_exists(categories)) {
    sampling_plan <- "categorical"
  }
  sampling_plan
}


#' Sort data by a grouping variable
#'
#' @param data A data matrix representing features or distances.
#' @param preclusters A vector of precluster affiliations. Can be NULL,
#'     see Details.
#' @param categories A vector that represents categorical constraints.
#'     Can be NULL, see Details.
#'
#' @return An extended data matrix. The first column indicates the
#'     group category of each element (precluster or categorical variable).
#'     The matrix is sorted by the group, i.e. by the first column.
#'     The second column is a unique number identifying the original
#'     position of each element. This column is used in
#'     \code{random_sampling} to restore the original order of
#'     the data. The other columns represent the original data inpute that
#'     was passed to this function.
#'
#'  @details
#'
#'  This function sorts the input table by precluster affiliation
#'  or by a categorical variable; neither needs to be present, if no
#'  grouping restrictions are passed (precluster or categories), the data
#'  is not sorted. It assumes that at most one of the arguments is not
#'  NULL.
#'
#' @noRd
#'

sort_by_group <- function(data, preclusters, categories) {
  sort_by <- 1 # default: data does not need to be sorted
  if (argument_exists(preclusters)) {
    sort_by <- preclusters
  } else if (argument_exists(categories)) {
    sort_by <- categories
  }
  dat <- cbind(sort_by, 1:nrow(data), data)
  dat <- sort_by_col(dat, 1)
  return(dat)
}

#' Random sampling for anticlustering
#'
#' @param dat The data input generated by
#'     \code{sort_data}, contains features or distances and
#'     information on grouping restrictions (as the first
#'     column, see \code{sort_by_group}).
#' @param K How many anticlusters should be created.
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param sampling_plan A string encoding how the anticlusters should be
#'     sampled. Is either "unrestricted" (anticlusters are simply
#'     shuffled), "preclustering" (preclustered elements are assigned
#'     to different groups) or "categorical" (the categorical variable
#'     is balanced out between anticlusters).
#' @param use_distances A boolean flag indicating whether `dat` contains
#'     distances or features. (TRUE = distances were passed)
#' @param parallelize Boolean. Indicates whether multiple processors should
#'     be used.
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling_ <- function(dat, K, nrep, sampling_plan,
                            obj_function) {

  ## Initialize variables
  N <- nrow(dat)
  n_preclusters <- N / K
  ## Start optimizing
  best_obj <- -Inf

  ## Select the relevant data from which the objective is computed
  objective_data <- dat[, -(1:2), drop = FALSE]
  anticlusters <- rep_len(1:K, N) # initialization for unrestricted sampling
  categories <- dat[, 1]
  for (i in 1:nrep) {
    if (sampling_plan == "unrestricted") {
      anticlusters <- sample(anticlusters)
    } else if (sampling_plan == "preclustering") {
      anticlusters <- replicate_sample(n_preclusters, K)
    } else if (sampling_plan == "categorical") {
      anticlusters <- categorical_sampling(categories, K)
    }
    cur_obj <- obj_function(anticlusters, objective_data)
    if (cur_obj > best_obj) {
      best_assignment <- anticlusters
      best_obj <- cur_obj
    }
  }
  return(best_assignment)
}

#' Random sampling employing a categorical constraint
#'
#' @param categories A vector of categories
#' @param K The number of anticlusters
#'
#' @return A random shuffling of the anticlusters that balances out
#'     the categories between samples
#'
#' @noRd

categorical_sampling <- function(categories, K) {
  init <- by(rep_len(1:K, length(categories)), categories, sample)
  unlist(init)
}

#' Replicate a random permutation of \code{1:N} several times
#'
#' @param times How many times should the random sample be generated
#' @param N The function returns several random permutations of
#'     \code{1:N}
#'
#' @return \code{times} random samples of \code{1:N} in a single vector
#'
#' @examples
#' replicate_sample(3, 3)
#'
#' @noRd
replicate_sample <- function(times, N) {
  c(replicate(times, sample(N)))
}
