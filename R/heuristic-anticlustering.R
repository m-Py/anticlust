
#' Heuristic anticlustering using random search methods
#'
#' @param features A data.frame, matrix or vector representing the
#'     features that are used.
#' @param K How many anticlusters should be created.
#' @param preclusters An optional vector representing the preclustering
#'     of the elements in \code{features}
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param distances Alternative data argument that can be used if
#'     \code{features} is not used. A N x N matrix representing the
#'     pairwise dissimilarities between all N elements. Larger values
#'     indicate higher dissimilarity. Can be an object of class
#'     \code{dist} (e.g., returned by \code{\link{dist}} or
#'     \code{\link{as.dist}}.
#' @param categories A vector, data.frame or matrix that represents
#'     one or several categorical constraints.
#' @param parallelize Boolean. Indicates whether multiple processors should
#'     be used.
#' @param seed A value to fixate the random seed when using the random
#'     sampling method. When \code{parallelize} is \code{TRUE}, using
#'     this argument is the only way to ensure reproducibility.
#' @param ncores The number of cores to be used when parallelize is TRUE.
#'     This argument is not
#'     accessible from the exported function \code{anticlustering} and
#'     only exists because R CMD check does not allows to use more than
#'     two cores.
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

heuristic_anticlustering <- function(features, K, preclusters, objective,
                                     nrep, distances, categories,
                                     parallelize, seed, ncores = NULL) {

  ## Determine objective function to be used
  categories <- merge_into_one_variable(categories) # may be NULL
  obj_function <- get_objective_function(features, distances, objective)
  sampling_plan <- get_sampling_plan(preclusters, categories)
  dat <- sort_by_group(features, distances, preclusters, categories)

  if (parallelize) {
    best_assignment <- parallel_sampling(
      dat,
      K,
      objective,
      nrep,
      sampling_plan,
      obj_function,
      seed,
      ncores
    )
  } else {
    if (argument_exists(seed)) {
      set.seed(seed)
    }
    best_assignment <- random_sampling(
      dat,
      K,
      objective,
      nrep,
      sampling_plan,
      obj_function
    )
  }

  ## Return anticluster assignment in original order
  dat[, 1] <- best_assignment
  dat <- sort_by_col(dat, 2)
  anticlusters <- dat[, 1]
  names(anticlusters) <- NULL
  anticlusters
}

#' Extracted from the above function for readability
get_sampling_plan <- function(preclusters, categories) {
  ## Determine plan for random sampling
  sampling_plan <- "unrestricted"
  if (argument_exists(preclusters)) {
    sampling_plan <- "preclustering"
  } else if (argument_exists(categories)) {
    sampling_plan <- "categorical"
  }
  sampling_plan
}


#' Determine the objective function needed for the input
#'
#' @noRd
get_objective_function <- function(features, distances, objective) {
  ## What was the input: features or distances
  use_distances <- FALSE
  if (argument_exists(features)) {
    input <- features
  } else {
    input <- distances
    use_distances <- TRUE
  }
  ## Determine how to compute objective, three cases:
  # 1. Distance objective, features were passed
  # 2. Distance objective, distances were passed
  # 3. Variance objective, features were passed
  if (objective == "distance" && use_distances == TRUE) {
    obj_value <- distance_objective_
  } else if (objective == "distance" && use_distances == FALSE) {
    obj_value <- obj_value_distance
  } else {
    obj_value <- variance_objective_
  }

}

#' Sort data by a grouping variable
#'
#' @param input A data matrix representing features or distances.
#' @param preclusters A vector of precluster affiliations. Can be NULL,
#'     see Details.
#' @param categories A vector that represents categorical constraints.
#'     Can be NULL, see Details.
#'
#' @return An extended data matrix. The first column indicates the
#'     group category of each element (precluster or categorical variable).
#'     The matrix is sorted by the group, i.e. by the first column.
#'     The second column is a unique number identifying the original
#'     position of each element. This column is used in
#'     \code{heuristic_anticlustering} to restore the original order of
#'     the data. The other columns represent the original data inpute that
#'     was passed to this function.
#'
#'  @details
#'
#'  This function sorts the input table by precluster affiliation
#'  or by a categorical variable; neither needs to be present, if no
#'  grouping restrictions are passed (precluster or categories), the data
#'  is not sorted. It assumes that at most one of the arguments is not
#'  NULL.
#'
#' @noRd
#'

sort_by_group <- function(features, distances, preclusters, categories) {
  if (argument_exists(features)) {
    input <- features
  } else {
    input <- distances
  }
  sort_by <- 1 # default: data does not need to be sorted
  if (argument_exists(preclusters)) {
    sort_by <- preclusters
  } else if (argument_exists(categories)) {
    sort_by <- categories
  }
  dat <- cbind(sort_by, 1:nrow(input), input)
  dat <- sort_by_col(dat, 1)
  return(dat)
}

#' Random sampling for anticlustering
#'
#' @param dat The data input generated by
#'     \code{sort_data}, contains features or distances and
#'     information on grouping restrictions (as the first
#'     column, see \code{sort_data}).
#' @param n_anticlusters How many anticlusters should be created.
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param sampling_plan A string encoding how the anticlusters should be
#'     sampled. Is either "unrestricted" (anticlusters are simply
#'     shuffled), "preclustering" (preclustered elements are assigned
#'     to different groups) or "categorical" (the categorical variable
#'     is balanced out between anticlusters).
#' @param use_distances A boolean flag indicating whether `dat` contains
#'     distances or features. (TRUE = distances were passed)
#' @param parallelize Boolean. Indicates whether multiple processors should
#'     be used.
#'
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling <- function(dat, K, objective, nrep, sampling_plan,
                            obj_function) {

  ## Initialize variables
  N <- nrow(dat)
  n_preclusters <- N / K
  ## Start optimizing
  best_obj <- -Inf

  ## Select the relevant data from which the objective is computed
  objective_data <- dat[, -(1:2), drop = FALSE]
  anticlusters <- rep_len(1:K, N) # initialization for unrestricted sampling
  categories <- dat[, 1]
  for (i in 1:nrep) {
    if (sampling_plan == "unrestricted") {
      anticlusters <- sample(anticlusters)
    } else if (sampling_plan == "preclustering") {
      anticlusters <- replicate_sample(n_preclusters, K)
    } else if (sampling_plan == "categorical") {
      anticlusters <- categorical_sampling(categories, K)
    }
    cur_obj <- obj_function(anticlusters, objective_data)
    if (cur_obj > best_obj) {
      best_assignment <- anticlusters
      best_obj <- cur_obj
    }
  }
  return(best_assignment)
}

#' Random sampling employing a categorical constraint
#'
#' @param categories A vector of categories
#' @param K The number of anticlusters
#'
#' @return A random shuffling of the anticlusters that balances out
#'     the categories between samples
#'
#' @noRd

categorical_sampling <- function(categories, K) {
  init <- by(rep_len(1:K, length(categories)), categories, sample)
  unlist(init)
}

#' Replicate a random permutation of \code{1:N} several times
#'
#' @param times How many times should the random sample be generated
#' @param N The function returns several random permutations of
#'     \code{1:N}
#'
#' @return \code{times} random samples of \code{1:N} in a single vector
#'
#' @examples
#' replicate_sample(3, 3)
#'
#' @noRd
replicate_sample <- function(times, N) {
  c(replicate(times, sample(N)))
}


#' Merge several grouping variable into one
#'
#' @param categories A vector, data.frame or matrix that represents
#'     one or several categorical constraints.
#'
#' @return A vector representing the group membership (or the combination
#'     of group memberships) as one variable
#'
#' @noRd
#'

merge_into_one_variable <- function(categories) {
  if (is.null(categories)) {
    return(NULL)
  }
  categories <- data.frame(categories)
  factor(do.call(paste0, as.list(categories)))
}
